# ${\color{lightblue}System \space Design}$
A System Design content repository.

### ${\color{lightblue}System \space Design \space Patterns}$

Below is a comprehensive table comparing the 15 design patterns. The table highlights each pattern’s purpose, when and why to use it, real‐world examples, how it’s integrated into microservices (especially in a Spring Boot context), and any relevant Spring annotations.

| ${\color{red}Pattern}$ | ${\color{red}Purpose}$ | ${\color{red}When \spaceto \space Use}$ | ${\color{red}Real-World \space Example}$ | ${\color{red}Microservices \space Integration}$ | ${\color{red}Annotations}$ | ${\color{red} Folder}$ |
|-|-|-|-|-|-|-|
| **Singleton**             | Ensures a class has only one instance and provides a global access point.                                         | Use when you need a shared resource (e.g., config, logging, connection pools) to avoid duplicate instances.      | Database connection managers, centralized logging systems                  | Spring beans are singletons by default; used for shared resources (e.g., DataSource, Environment).             | `@Component`, `@Service`, `@Repository` (default singleton scope)           | [Folder]() |
| **Factory**               | Encapsulates object creation logic, letting subclasses decide which class to instantiate.                         | Use when object creation is complex or varies based on runtime conditions.                                      | Notification factories, payment gateway factories                         | Use `FactoryBean` or `@Configuration` classes with `@Bean` methods to create components dynamically.           | `@Configuration`, `@Bean`, `FactoryBean`                                    | [Folder]() |
| **Builder**               | Constructs complex objects step-by-step, separating construction from representation.                            | Use when objects have many optional parameters or complex configurations.                                       | Building complex DTOs, constructing orders or user profiles                | Often used in DTO creation or request/response builders; Lombok’s builder pattern simplifies code in Spring Boot.  | Lombok’s `@Builder` (or custom builder pattern implementations)              | [Folder]() |
| **Observer**              | Defines a one-to-many dependency so that when one object changes state, all its dependents are notified.             | Use for event-driven architectures where components need to react to changes.                                   | Event notification systems, real-time data feeds                           | Implemented via Spring’s ApplicationEvents; decouples event producers and consumers using `@EventListener`.       | `@EventListener`, `@Async` (for async event processing)                     | [Folder]() |
| **Proxy**                 | Provides a surrogate that controls access to another object, adding functionality (e.g., caching, security).         | Use for adding cross-cutting concerns like security, caching, or lazy loading without modifying business code.    | API Gateways, security proxies, rate limiters                              | Implement cross-cutting concerns via Spring AOP proxies; often used in API gateways and security modules.         | `@Aspect`, `@EnableAspectJAutoProxy`                                       | [Folder]() |
| **Strategy**              | Encapsulates a family of algorithms, allowing them to be interchanged at runtime.                                 | Use when you need to choose between different behaviors or algorithms dynamically.                              | Routing strategies in navigation, discount calculation strategies          | Leverage dependency injection to select between multiple strategies based on configuration or context.           | `@Component`, `@Qualifier`, `@Primary`                                      | [Folder]() |
| **Adapter**               | Converts one interface into another to allow incompatible interfaces to work together.                            | Use when integrating legacy systems or third-party APIs that don’t match your internal interfaces.                | Legacy payment API adapters, third-party integration wrappers               | Wrap external services with adapter classes to conform to your internal APIs, promoting interoperability.          | `@Component`                                                              | [Folder]() |
| **Decorator**             | Dynamically adds responsibilities or behaviors to objects without altering their structure.                        | Use when you need to enhance an object’s functionality (e.g., logging, security, caching) dynamically.             | Adding logging or security to service calls                                | Use Spring AOP or bean decorators to inject additional behavior into services without modifying core logic.       | `@Aspect`, `@Component`                                                   | [Folder]() |
| **Command**               | Encapsulates a request as an object, decoupling the sender from the receiver.                                     | Use for task scheduling, job queues, or implementing undo/redo functionality.                                  | Task schedulers, message-based command execution (e.g., remote service calls) | Use with messaging frameworks (RabbitMQ, Kafka) where commands are dispatched as messages; also seen in Spring Integration. | `@Service`, Spring Integration’s `@ServiceActivator` (if applicable)          | [Folder]() |
| **Facade**                | Provides a simplified interface to a complex subsystem.                                                          | Use to hide the complexity of subsystems behind a simple interface for the client.                               | API Gateways that aggregate multiple microservices                         | Create unified endpoints that hide the underlying complexity of multiple services; simplifies client interactions. | `@RestController`, `@Service`, `@Component`                                | [Folder]() |
| **Flyweight**             | Reduces memory usage by sharing common state among multiple objects.                                               | Use when you need to manage large numbers of similar objects efficiently (minimizing memory footprint).            | Caching mechanisms, shared UI components                                   | Optimize caching or object pooling strategies to reduce memory overhead; can be paired with Spring caching.        | `@Cacheable` (for caching aspects), `@Component`                           | [Folder]() |
| **Mediator**              | Centralizes communication among multiple objects, reducing direct dependencies.                                  | Use when many components interact and need to be decoupled, simplifying communication.                           | Chat room systems, centralized message buses                               | Implement as a central event bus or use Spring Cloud Bus to manage communications between microservices.          | `@EventListener`, `@Component`                                            | [Folder]() |
| **State**                 | Allows an object to alter its behavior when its internal state changes.                                            | Use when an object’s behavior must vary based on its current state, supporting dynamic state transitions.         | Order lifecycle management (new, shipped, delivered)                       | Use frameworks like Spring State Machine to handle complex state transitions in microservices or workflows.        | *(Typically configured via Spring State Machine; no direct annotation)*     | [Folder]() |
| **Template Method**       | Defines the skeleton of an algorithm, allowing subclasses to redefine specific steps without changing the structure. | Use when you have a common process with fixed steps but need customization for certain parts.                      | Data processing pipelines, ETL operations                                  | Standardize business processes in Spring Boot controllers or services by defining abstract workflows.              | *(No direct annotation; abstract classes can be registered as components if needed)* | [Folder]() |
| **Chain of Responsibility** | Passes a request along a chain of handlers until one handles it, decoupling sender and receiver.                  | Use for sequential processing of requests such as authentication, logging, or filtering in middleware.            | HTTP request filtering (e.g., security filter chains)                      | Implement as servlet filters or interceptors (e.g., Spring Security filter chain) to process HTTP requests modularly. | `@Component`, `@Order` (for ordering filters/interceptors)                 | [Folder]() |

---

This table should provide a clear, side-by-side comparison of each design pattern along with how and when they are used, real-world scenarios, and how they integrate with microservices and Spring Boot.
